import express, { type Request, type Response, type NextFunction, type RequestHandler } from 'express';
import type { Request as ExpressRequest } from 'express-serve-static-core';
import Joi from 'joi';
import { ProjectStatus } from '../models/project.model.js';
import { ProjectRole } from '../models/project-member.model.js';
import { auth } from '../middleware/auth.middleware.js';
import ProjectController from '../controllers/project.controller.new.js';

// Extend Express Request type to include user
declare module 'express-serve-static-core' {
  interface Request {
    user?: {
      id: string | number;
      roles?: Array<{ name: string }>;
    };
  }
}

type AuthenticatedRequest = ExpressRequest & {
  user: {
    id: string | number;
    roles?: Array<{ name: string }>;
  };
};

// Joi validation schemas
const projectSchema = Joi.object({
  name: Joi.string().required().min(3).max(100).label('Project Name'),
  description: Joi.string().allow('').max(500).label('Description'),
  status: Joi.string()
    .valid(...Object.values(ProjectStatus))
    .default(ProjectStatus.PLANNING)
    .label('Status'),
  startDate: Joi.date().iso().allow(null).label('Start Date'),
  endDate: Joi.date()
    .iso()
    .min(Joi.ref('startDate'))
    .allow(null)
    .label('End Date')
    .when('startDate', {
      is: Joi.exist(),
      then: Joi.date().min(Joi.ref('startDate')),
      otherwise: Joi.date().min('now')
    })
}).required().label('Project Data');

const updateProjectSchema = Joi.object({
  name: Joi.string().min(3).max(100).label('Project Name'),
  description: Joi.string().allow('').max(500).label('Description'),
  status: Joi.string()
    .valid(...Object.values(ProjectStatus))
    .label('Status'),
  startDate: Joi.date().iso().allow(null).label('Start Date'),
  endDate: Joi.date()
    .iso()
    .allow(null)
    .label('End Date')
    .when('startDate', {
      is: Joi.exist(),
      then: Joi.date().min(Joi.ref('startDate')),
      otherwise: Joi.date()
    })
}).min(1).label('Project Update Data');

const projectMemberRoleSchema = Joi.object({
  role: Joi.string()
    .valid(...Object.values(ProjectRole))
    .default(ProjectRole.VIEWER)
    .label('Role')
}).required().label('Project Member Role');

// Validation middleware
const validateRequest = (schema: Joi.ObjectSchema): RequestHandler => {
  return (req: Request, res: Response, next: NextFunction) => {
    const { error, value } = schema.validate(req.body, { 
      abortEarly: false,
      allowUnknown: false,
      stripUnknown: true
    });
    
    if (error) {
      const errors = error.details.map(detail => ({
        field: Array.isArray(detail.path) ? detail.path.join('.') : String(detail.path),
        message: detail.message.replace(/['"]/g, '')
      }));
      
      res.status(400).json({
        success: false,
        message: 'Validation failed',
        errors
      });
      return;
    }
    
    // Replace request body with validated value
    (req as any).body = value;
    next();
  };
};

// Type guard to check if user is authenticated
const isAuthenticated = (req: ExpressRequest): req is AuthenticatedRequest => {
  return !!(req as AuthenticatedRequest).user;
};

// Helper function to ensure request is authenticated
const ensureAuthenticated = (req: ExpressRequest): AuthenticatedRequest => {
  if (!isAuthenticated(req)) {
    throw new Error('User is not authenticated');
  }
  return req as AuthenticatedRequest;
};

const router = express.Router();

// Apply auth middleware to all routes
router.use(auth);

// Create a new project
router.post(
  '/',
  validateRequest(projectSchema),
  async (req: Request, res: Response, next: NextFunction) => {
    try {
      const authReq = ensureAuthenticated(req);
      await ProjectController.createProject(authReq, res);
    } catch (error) {
      next(error);
    }
  }
);

// Get all projects for the current user with pagination
router.get(
  '/',
  async (req: Request, res: Response, next: NextFunction) => {
    try {
      const authReq = ensureAuthenticated(req);
      await ProjectController.getProjects(authReq, res);
    } catch (error) {
      next(error);
    }
  }
);

// Get project by ID with members and testers
router.get(
  '/:projectId',
  async (req: Request, res: Response, next: NextFunction) => {
    try {
      const authReq = ensureAuthenticated(req);
      await ProjectController.getProjectById(authReq, res);
    } catch (error) {
      next(error);
    }
  }
);

// Update project
router.put(
  '/:projectId',
  validateRequest(updateProjectSchema),
  async (req: Request, res: Response, next: NextFunction) => {
    try {
      const authReq = ensureAuthenticated(req);
      await ProjectController.updateProject(authReq, res);
    } catch (error) {
      next(error);
    }
  }
);

// Delete project
router.delete(
  '/:projectId',
  async (req: Request, res: Response, next: NextFunction) => {
    try {
      const authReq = ensureAuthenticated(req);
      await ProjectController.deleteProject(authReq, res);
    } catch (error) {
      next(error);
    }
  }
);

export default router;
